#if SERVER
global function SilenceThink
#endif //SERVER
global function MpAbilitySharedSilence_Init
                              
                                    
                                   

//SILENCE FX
const asset FX_SILENCE_REV_VICTIM_1P = $"P_bSilent_screen_CP"
const asset FX_SILENCE_REV_VICTIM_3P = $"P_bSilent_body"
const asset SHADOW_SCREEN_FX = $"P_Bshadow_screen"

global enum eSilenceOwner
{
	REVENANT,
	_count
}

const bool SILENCE_DEBUG_STATUSEFFECT = false

struct
{
	int colorCorrectionRev
	int ScreenFxIdRev
	table<int,float> teamDebounceTimes

	array<int> silenceStatusEffects

	float effectDurationRev
	float interruptedDuration

	#if SERVER
		array<string> abilitiesToCancel
	#endif
} file

void function MpAbilitySharedSilence_Init()
{
	file.interruptedDuration = GetCurrentPlaylistVarFloat( "silence_interrupt_duration", 0.25 )

	RegisterSignal( "Interrupted" )

#if CLIENT
	AddCallback_OnWeaponStatusUpdate( Silenced_WeaponStatusCheck )

	RegisterSignal( "AbilitySilence_StopColorCorrection" )
	file.ScreenFxIdRev = PrecacheParticleSystem( FX_SILENCE_REV_VICTIM_1P )
	file.colorCorrectionRev = ColorCorrection_Register( "materials/correction/ability_silence.raw_hdr" )

	StatusEffect_RegisterEnabledCallback( eStatusEffect.silenced_rev_visuals, AbilitySilence_StartVisualEffect )
	StatusEffect_RegisterDisabledCallback( eStatusEffect.silenced_rev_visuals, AbilitySilence_StopVisualEffect )

	StatusEffect_RegisterEnabledCallback( eStatusEffect.interrupted, Interrupted_ClientCallbacks )

#else
	Bleedout_AddCallback_OnPlayerStartBleedout( OnPlayerStartBleedout_Silence )
	RegisterSignal( "StopSilence")

	file.abilitiesToCancel = [
		"mp_weapon_grenade_bangalore",
		"mp_ability_silence",
		"mp_ability_gibraltar_shield",
		"mp_ability_phase_walk",
		"mp_ability_phase_tunnel",
		"mp_weapon_zipline",
	]

                               
                               
   
                                                           
   
      
	#endif
}

#if SERVER
void function SilenceThink( entity ent, entity silenceOwner, float silenceAreaDuration, float silenceEffectDuration, bool applyInterrupt=false, bool isEndless=false )
{
	ent.EndSignal( "OnDestroy" )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "StopSilence" )

	//Play effect on player so we can see they are silenced.
	int attachmentID = ent.LookupAttachment( "CHESTFOCUS" )
	int fxID
	int silenceVisualsStatusEffect
	bool fxVisible = true
	float endTime = Time() + silenceEffectDuration

	if ( PlayerHasPassive( silenceOwner, ePassives.PAS_DEATHSTALKER ) )
	{
		fxID                = GetParticleSystemIndex( FX_SILENCE_REV_VICTIM_3P )
		silenceVisualsStatusEffect = eStatusEffect.silenced_rev_visuals
	}
                 
                                                                     
  
                                                                           
                                                                  
  
                      

	entity fx = StartParticleEffectOnEntity_ReturnEntity ( ent, fxID, FX_PATTACH_POINT_FOLLOW, attachmentID )
	fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY
	fx.SetOwner( ent )

	SetCanDoDamageCallout( ent, false )
	int victimTeam = ent.GetTeam() //Ent is assumed to be a player above

	//Seer's silence is short enough that we're going to turn off the battle chatter for it.  The focus is more on the interrupt than a long term disable.
	bool playBattleChatter = PlayerHasPassive( silenceOwner, ePassives.PAS_DEATHSTALKER )

	if ( playBattleChatter )
	{
		if ( victimTeam in file.teamDebounceTimes )
		{
			if ( file.teamDebounceTimes[victimTeam] < Time() )
			{
				file.teamDebounceTimes[victimTeam] = Time() + silenceAreaDuration
				PlayBattleChatterLineToSpeakerAndTeam( ent, "bc_abilitiesBlocked" )
			}
		}
		else
		{
			file.teamDebounceTimes[victimTeam] <- Time() + silenceAreaDuration
			PlayBattleChatterLineToSpeakerAndTeam( ent, "bc_abilitiesBlocked" )
		}
	}

	ent.Signal( "PhaseTunnel_CancelPlacement" )
	int silenceVisualsHandle
	int silenceHandle
	if( isEndless )
	{
		silenceVisualsHandle = StatusEffect_AddEndless( ent, silenceVisualsStatusEffect, 1.0 )
		silenceHandle = StatusEffect_AddEndless( ent, eStatusEffect.silenced, 1.0 )
	}
	else
	{
		StatusEffect_AddTimed( ent, silenceVisualsStatusEffect, 1.0, silenceEffectDuration, silenceEffectDuration )
		StatusEffect_AddTimed( ent, eStatusEffect.silenced, 1.0, silenceEffectDuration, silenceEffectDuration )
	}

	if ( applyInterrupt )
	{
		StatusEffect_AddTimed( ent, eStatusEffect.interrupted, 1.0, Interrupt_GetEffectDuration(), Interrupt_GetEffectDuration() )

		Signal( ent, "Interrupted" )

		if ( PlayerHasPassive( ent, ePassives.PAS_OCTANE ) )
		{
			ent.Signal( "EndStim" )
		}

		if ( InterruptedStopsHeals() )
		{
			thread DisableHealing_Thread( ent, Interrupt_GetEffectDuration() )
		}

		if ( InterruptedStopsFinishers() )
		{
			ent.Signal( "InterruptSyncedMelee" )
		}
	}

	string silenceLoopSound_3p = "Silence_Victim_Loop_3p"

	if ( ent.IsPlayer() )
	{
		EmitSoundOnEntityExceptToPlayer( ent, ent, silenceLoopSound_3p )
	}
	else
	{
		EmitSoundOnEntity( ent, silenceLoopSound_3p )
	}

	if( ent.IsPlayer() && silenceOwner.IsPlayer() )
	{
		AddAssistingPlayerToVictim( silenceOwner, ent, Silence_GetEffectDuration() ) //Note: Only works because we don't have things that prematurely clears status effects, e.g. no cleanse etc.
	}

	bool shouldSwap = true
	array <entity> activeWeapons = ent.GetAllActiveWeapons()
	if ( activeWeapons.len() > 0 )
	{
		entity activeWeapon = activeWeapons[0]
		if ( IsValid( activeWeapon ) )
		{
			shouldSwap = IsBitFlagSet( activeWeapon.GetWeaponTypeFlags(), WPT_TACTICAL ) || IsBitFlagSet( activeWeapon.GetWeaponTypeFlags(), WPT_ULTIMATE )
		}

		if ( activeWeapons.len() > 1 )
		{
			entity offhandWeapon = activeWeapons[1]
			if ( IsValid( offhandWeapon ) )
			{
				if ( file.abilitiesToCancel.contains( offhandWeapon.GetWeaponClassName() ) )
					ent.ClearOffhand( eActiveInventorySlot.altHand )
			}
		}
	}

	if ( shouldSwap )
		SwapToLastEquippedPrimary( ent )

	ent.GrappleDetach()
	//ent.DisableWeaponTypes( WPT_ULTIMATE | WPT_TACTICAL )

	if( PlayerHasPassive( ent, ePassives.PAS_CRYPTO ) )
		Drone_ExitView( ent )

                               
                               
                                           
                                         

	OnThreadEnd(
		function() : ( ent, silenceOwner, fx, silenceLoopSound_3p, isEndless, silenceVisualsHandle, silenceHandle )
		{
			if ( IsValid( ent ) )
			{
				//ent.EnableWeaponTypes( WPT_ULTIMATE | WPT_TACTICAL )

                                  
                                  
                                             
                                           

				SetCanDoDamageCallout( ent, true )
				StopSoundOnEntity( ent, silenceLoopSound_3p )

				if( isEndless )
				{
					StatusEffect_Stop( ent, silenceVisualsHandle )
					StatusEffect_Stop( ent, silenceHandle )
				}
			}

			if ( IsValid( fx ) )
				EffectStop( fx )
		}
	)

	while ( StatusEffect_GetSeverity( ent, eStatusEffect.silenced ) > 0.0)
	{
		if ( ent.IsPhaseShiftedOrPending() )
		{
			if ( fxVisible )
			{
				fx.kv.VisibilityFlags = ENTITY_VISIBLE_TO_NOBODY
				fxVisible = false
			}
		}
		else
		{
			if ( !fxVisible )
			{
				fx.kv.VisibilityFlags = ( ENTITY_VISIBLE_TO_FRIENDLY | ENTITY_VISIBLE_TO_ENEMY )
				fxVisible = true
			}
		}

		WaitFrame()
	}
}

void function DisableHealing_Thread( entity ent, float duration )
{
	Assert ( IsNewThread(), "Must be threaded off." )
	ent.EndSignal( "OnDeath" )
	ent.EndSignal( "OnDestroy" )

	OnThreadEnd(
		function() : ( ent )
		{
		//	ent.EnableWeaponTypes( WPT_CONSUMABLE )
		}
	)

	//ent.DisableWeaponTypes( WPT_CONSUMABLE )

	wait duration
}

void function OnPlayerStartBleedout_Silence( entity player, entity attacker, var damageInfo )
{
	player.Signal( "StopSilence" )
}
#endif //SERVER

#if CLIENT
void function Silenced_WeaponStatusCheck( entity player, var rui, int slot )
{
	switch ( slot )
	{
		case OFFHAND_LEFT:
		case OFFHAND_INVENTORY:
			bool overwrite = false
			if( slot == OFFHAND_LEFT)
			{
				//Some legends have custom tactical RUI's, to ensure we write the silenced information to them, we
				//overwrite them here
				if ( PlayerHasPassive( player, ePassives.PAS_CRYPTO ) )
				{
					overwrite = true
					rui = GetCryptoAnimatedTacticalRui()
				}
			}


			if ( rui != null )
			{
				if ( StatusEffect_GetSeverity( player, eStatusEffect.silenced ) > 0.0 )
				{
					if ( !overwrite )
						RuiSetString( rui, "hintText", "" )
					RuiSetBool( rui, "isSilenced", true )
					if ( StatusEffect_GetSeverity( player, eStatusEffect.silenced_rev_visuals ) > 0.0 )
					{
						//RuiSetInt( rui, "silenceOwner", eSilenceOwner.REVENANT )
					}
				}
				else
				{
					RuiSetBool( rui, "isSilenced", false )
				}
			}
			break
	}
}

void function AbilitySilence_StartVisualEffect( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged && GetLocalViewPlayer() == GetLocalClientPlayer() )
		return

	if ( ent != GetLocalViewPlayer() )
		return

	entity viewPlayer = ent

	//EmitSoundOnEntity( viewPlayer, SILENCE_SOUND_VICTIM )

	thread AbilitySilence_UpdatePlayerScreenColorCorrection( viewPlayer, statusEffect )
	int screenFxId

	switch ( statusEffect )
	{
		case eStatusEffect.silenced_rev_visuals:
			screenFxId = file.ScreenFxIdRev
			break
		default:
			Warning( FUNC_NAME() + " unknown silence status effect!  Defaulting to Revenants's" )
			screenFxId = file.ScreenFxIdRev
			break
	}

	int fxHandle = StartParticleEffectOnEntityWithPos( viewPlayer, screenFxId, FX_PATTACH_ABSORIGIN_FOLLOW, -1, viewPlayer.EyePosition(), <0,0,0> )
	EffectSetIsWithCockpit( fxHandle, true )

	thread AbilitySilence_ScreenEffectThread( viewPlayer, fxHandle, statusEffect )
}


void function AbilitySilence_StopVisualEffect( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( !actuallyChanged && GetLocalViewPlayer() == GetLocalClientPlayer() )
		return

	if ( ent != GetLocalViewPlayer() )
		return

	if ( IsAlive( ent ) )
	{
		EmitSoundOnEntity( ent, "Survival_UI_Ability_Ready_SilenceEnded" )
	}

	ent.Signal( "AbilitySilence_StopColorCorrection" )
}


void function AbilitySilence_UpdatePlayerScreenColorCorrection( entity player, int statusEffect )
{
	Assert ( IsNewThread(), "Must be threaded off." )
	Assert ( player == GetLocalViewPlayer() )

	player.EndSignal( "OnDeath" )
	player.EndSignal( "OnDestroy" )
	player.EndSignal( "AbilitySilence_StopColorCorrection" )

	int colorCorrection

	switch( statusEffect )
	{
		case eStatusEffect.silenced_rev_visuals:
			colorCorrection = file.colorCorrectionRev
			break
		default:
			Warning(FUNC_NAME() + " unhandled silenced status effect, defaulting to Revenant's")
			colorCorrection = file.colorCorrectionRev
			break
	}

	OnThreadEnd(
		function() : ( player, colorCorrection )
		{
			ColorCorrection_SetWeight( colorCorrection, 0.0 )
			ColorCorrection_SetExclusive( colorCorrection, false )
		}
	)

	ColorCorrection_SetExclusive( colorCorrection, true )
	ColorCorrection_SetWeight( colorCorrection, 1.0 )

	//const LERP_IN_TIME = 0.0125	// hack! because statusEffect doesn't seem to have a lerp in feature?
	float startTime = Time()

	while ( true )
	{
		float timeRemaining = StatusEffect_GetTimeRemaining( player, statusEffect )
		float normalizedTime = timeRemaining / Silence_GetEffectDuration()

		ColorCorrection_SetWeight( colorCorrection, normalizedTime )

		WaitFrame()
	}
}


void function AbilitySilence_ScreenEffectThread( entity viewPlayer, int fxHandle, int statusEffect )
{
	EndSignal( viewPlayer, "OnDeath" )
	EndSignal( viewPlayer, "AbilitySilence_StopColorCorrection" )

	string silenceSound = ""

	switch ( statusEffect )
	{
		case eStatusEffect.silenced_rev_visuals:
			silenceSound = "Silence_Victim_Loop_1p"
			break
		default:
			Warning( FUNC_NAME() + " unknown silence status effect!  Defaulting to Revenants's" )
			silenceSound = "Silence_Victim_Loop_1p"
			break
	}
	
	entity cockpit = viewPlayer.GetCockpit()
		if ( !IsValid( cockpit ) )
			return
	
	int fxHandleScreen = StartParticleEffectOnEntity( cockpit, PrecacheParticleSystem( SHADOW_SCREEN_FX ), FX_PATTACH_ABSORIGIN_FOLLOW, -1 )
	viewPlayer.p.shadowFxHandles.append(fxHandleScreen)
	EffectSetIsWithCockpit( fxHandleScreen, true )
	vector controlPoint = <1,1,1>
	EffectSetControlPointVector( fxHandleScreen, 1, controlPoint )

	OnThreadEnd(
		function() : ( fxHandleScreen, fxHandle, viewPlayer, silenceSound )
		{
			if ( !EffectDoesExist( fxHandle ) )
				return
				
			if ( !EffectDoesExist( fxHandleScreen ) )
				return

			EffectStop( fxHandle, false, true )
			EffectStop( fxHandleScreen, false, true )
			if ( IsValid( viewPlayer ) )
			{
				if ( silenceSound != "" )
				{
					StopSoundOnEntity( viewPlayer, "Silence_Victim_Loop_1p" )
				}
			}
		}
	)


	if ( silenceSound != "" )
	{
		EmitSoundOnEntity( viewPlayer, silenceSound )
	}
	
	bool stopSoundOnce = false
	while( true )
	{
		float timeRemaining = StatusEffect_GetTimeRemaining( viewPlayer, statusEffect )
		float CP1Value = timeRemaining / Silence_GetEffectDuration()

		if ( !EffectDoesExist( fxHandle ) )
			break

		EffectSetControlPointVector( fxHandle, 1, <CP1Value,255,255> )
		if ( ( stopSoundOnce == false ) && ( timeRemaining < 3 ) && ( statusEffect == eStatusEffect.silenced_rev_visuals ) )
		{
			stopSoundOnce = true
			StopSoundOnEntity( viewPlayer, silenceSound )
		}
		WaitFrame()
	}
}

//The interrupted debuff is set on server, handle any special client side interrupted logic here.
void function Interrupted_ClientCallbacks( entity ent, int statusEffect, bool actuallyChanged )
{
	if ( ent != GetLocalViewPlayer() || ( GetLocalViewPlayer() == GetLocalClientPlayer() && !actuallyChanged) )
		return

	Signal( ent, "Interrupted" )

	//if ( GetCurrentPlaylistVarBool( "interrupted_closes_crafting_menu", true ) )
		//TryCloseCraftingMenu()
}
#endif //CLIENT

                              
                                    
 
                                                                   
 
                                   

bool function InterruptedStopsHeals()
{
	return GetCurrentPlaylistVarBool( "interrupted_disables_heal", false )
}

bool function InterruptedStopsFinishers()
{
	return GetCurrentPlaylistVarBool( "interrupted_stops_finishers", true )
}

float function Interrupt_GetEffectDuration()
{
	return file.interruptedDuration
}